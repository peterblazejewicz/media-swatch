<link rel="import" href="/bower_components/polymer/polymer.html">

<dom-module id="median-cut">
    <template>
        <style>
             :host {
                display: inline-block;
            }
        </style>
        <canvas id="canvas" hidden></canvas>
        <img id="image" hidden></image>
    </template>

    <script>
        /**
         * @customElement
         * @polymer
         */
        class MedianCut extends Polymer.Element {
            static get DEFAULT_DEPTH() {
                return 4;
            }
            static get is() {
                return 'median-cut';
            }
            static get properties() {
                return {
                    file: {
                        type: Object,
                        observer: '_fileChanged'
                    },
                    _fileReader: {
                        notify: false,
                        type: FileReader,
                        readOnly: true,
                        value: null
                    }
                };
            }

            constructor() {
                super();
                this._fileChanged = this._fileChanged.bind(this);
                this._loadFile = this._loadFile.bind(this);
                this._imageLoaded = this._imageLoaded.bind(this);
                this._ctx = null;
            }

            get ctx() {
                if (!this._ctx) {
                    this._ctx = this.$.canvas.getContext('2d');
                    this._ctx.mozImageSmoothingEnabled = false;
                    this._ctx.msImageSmoothingEnabled = false;
                    this._ctx.imageSmoothingEnabled = false;
                }
                return this._ctx;
            }

            connectedCallback() {
                super.connectedCallback();
                this.$.image.addEventListener('load', this._imageLoaded);
            }

            diconnectedCallback() {
                super.disconnectedCallback();
                this.$.image.removeEventListener('load', this._imageLoaded);
            }

            _fileChanged() {
                console.log(this._fileChanged.name);
                if (this._fileReader === null) {
                    this._set_fileReader(new FileReader());
                    this._fileReader.onload = this._loadFile.bind(this);
                }
                this._fileReader.readAsDataURL(this.file);
            }

            _loadFile(event) {
                console.log(this._loadFile.name);
                this.$.image.src = event.target.result;
            }

            _imageLoaded(event) {
                console.log(this._imageLoaded.name);
                const width = this.$.image.width;
                const height = this.$.image.height;
                this.$.canvas.width = width;
                this.$.canvas.height = height;
                this.ctx.drawImage(this.$.image, 0, 0);
                let imageData = this.ctx.getImageData(0, 0, width, height);
                let rgbPixels = this._convertToRGBPixels(imageData);
            }

            _convertToRGBPixels(imageData) {
                const width = imageData.width;
                const height = imageData.height;
                const rgbVals = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4;
                        rgbVals.push({
                            r: imageData.data[index],
                            g: imageData.data[index + 1],
                            b: imageData.data[index + 2]
                        });
                    }
                }
                return rgbVals;
            }

            static _findBiggestRange(rgbVals) {
                let rMin = Number.POSITIVE_INFINITY;
                let rMax = Number.NEGATIVE_INFINITY;

                let gMin = Number.POSITIVE_INFINITY;
                let gMax = Number.NEGATIVE_INFINITY;

                let bMin = Number.POSITIVE_INFINITY;
                let bMax = Number.NEGATIVE_INFINITY;

                rgbVals.forEach(pixel => {
                    rMin = Math.min(rMin, pixel.r);
                    rMax = Math.max(rMax, pixel.r);
                    gMin = Math.min(gMin, pixel.g);
                    gMax = Math.max(gMax, pixel.g);
                    bMin = Math.min(bMin, pixel.b);
                    bMax = Math.max(bMax, pixel.b);
                });

                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;

                const biggestRange = Math.max(rRange, gRange, bRange);
                if (biggestRange === rRange) {
                    return 'r';
                } else if (biggestRange === gRange) {
                    return 'g';
                }
                return 'b';
            };

            static quantize(rgbVals, depth = 0, maxDepth = MedianCut.DEFAULT_DEPTH) {
                if (depth === 0) {
                    console.log(`Quantizing to ${Math.pow(2, maxDepth)} buckets.`);
                }
                // Base case: average the RGB values down to a single average value.
                if (depth === maxDepth) {
                    const color = rgbVals.reduce((prev, curr) => {
                        prev.r += curr.r;
                        prev.g += curr.g;
                        prev.b += curr.b;
                        return prev;
                    }, {
                        r: 0,
                        g: 0,
                        b: 0
                    });

                    color.r = Math.round(color.r / rgbVals.length);
                    color.g = Math.round(color.g / rgbVals.length);
                    color.b = Math.round(color.b / rgbVals.length);

                    return [color];
                }

                // Recursive case: find the component with the biggest range,
                // sort by it, then divide the RGB values in half, and go again.
                const componentToSortBy = MedianCut._findBiggestRange(rgbVals);
                rgbVals.sort((p1, p2) => {
                    return p1[componentToSortBy] - p2[componentToSortBy];
                });

                const mid = rgbVals.length / 2;
                return [...MedianCut.quantize(rgbVals.slice(0, mid), depth + 1, maxDepth),
                    ...MedianCut.quantize(rgbVals.slice(mid + 1), depth + 1, maxDepth)
                ];
            }

            static orderByLuminance(rgbVals) {
                const calcLuminance = p => {
                    return 0.2126 * p.r + 0.7152 * p.g + 0.0722 * p.b;
                };

                return rgbVals.sort((p1, p2) => {
                    return calcLuminance(p1) - calcLuminance(p2);
                });
            }

            static getMostVariantColor(rgbVals) {
                let index = 0;
                let max = Number.NEGATIVE_INFINITY;
                rgbVals
                    // Remap each RGB value to a variance by taking the max component from the
                    // min component.
                    .map(v => Math.max(v.r, v.g, v.b) - Math.min(v.r, v.g, v.b))

                    // Then step through each value and find which has the largest value.
                    .forEach((v, i) => {
                        if (v > max) {
                            index = i;
                            max = v;
                        }
                    });

                return rgbVals[index];
            }

            static lighten(rgbVal, percentage) {
                const factor = 1 + (percentage / 100);
                return MedianCut._adjustColor(rgbVal, factor);
            }

            static darken(rgbVal, percentage) {
                const factor = 1 - (percentage / 100);
                return MedianCut._adjustColor(rgbVal, factor);
            }

            static _clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            static _adjustColor(rgbVal, factor) {
                return {
                    r: MedianCut._clamp(Math.round(rgbVal.r * factor), 0, 255),
                    g: MedianCut._clamp(Math.round(rgbVal.g * factor), 0, 255),
                    b: MedianCut._clamp(Math.round(rgbVal.b * factor), 0, 255)
                };
            }
        }

        window.customElements.define(MedianCut.is, MedianCut);
    </script>
</dom-module>